# JAVA修饰符

Table of Contents
=================

   * [JAVA修饰符](#java修饰符)
      * [ABSTRACT](#abstract)
      * [FINAL](#final)
      * [INTERFACE](#interface)
      * [NATIVE](#native)
      * [PRIVATE，PROTECTED，PUBLIC](#privateprotectedpublic)
      * [STATIC](#static)
      * [STRICTFP](#strictfp)
      * [SYNCHRONIZED](#synchronized)
      * [TRANSIENT](#transient)
      * [VOLATILE](#volatile)
      * [参考](#参考)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)

**java.lang.reflect.Modifier**

## ABSTRACT

Abstract(抽象)可以修饰类、方法。包含一个或多个抽象方法的类本身必须被声明为抽象类。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择：

+ 一种是在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；
+ 另一种是定义全部的抽象方法，这样子类就不是抽象类了。

类即使不含有抽象方法也可以将类声明为抽象类。抽象类不能实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。不过可以定义一个抽象类的对象变量，但是它只能引用继承抽象类的非抽象子类的对象。

注意比较：

``` java
	private void print(){}；// 此语句表示方法的空实现。
	abstract void print()； // 此语句表示方法的抽象，无实现。
```

Abstract和static或者Abstract和final不能放在一起，否则便会出现错误。

## FINAL

final可以修饰类，方法，域。

域被声明为final，则构造对象之后就不允许改变它们的值了。如果被修饰的域是对象引用，则对象内的值还是可以改变的，但是对象的引用不能改变。（必须初始化，不能被修改）

方法被声明为final，可以确保方法不会在子类中改变语义，就是说不能被子类覆盖。

PS：早期JAVA中，有时为了避免动态绑定带来的系统开销而使用final修饰符。如果一个方法很短并且没有被覆盖，编译器就能够对它进行优化处理，这个过程被称为内联（inlining）。例如，内联调用e.getName()将被替换为访问e.name域。这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令策略，增加系统开销，使用内联可以避免这一开销。但是，如果getName在另一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此就不能对它进行内敛处理了。

不过现在虚拟机中的即时编译器比传统编译器的处理能力要强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法简短，被调用频繁而且没有真正地被覆盖，那么即时编译器就会对这个方法进行内联处理。如果虚拟机加载了另一个类，而在这个类中包含对内联方法的覆盖，那么优化器将取消对覆盖方法的内联。这过程很慢而且很少发生。

类被声明为final，相当于其中的方法自动成为final方法，但是不包括类中的域。这种操作可以阻止利用被修饰的类定义子类。就是说不允许被继承的类被称为final类。一般来说一个类要么为继承设计，并提供文档说明；要么就禁止继承，成为一个final类。

## INTERFACE

在JAVA语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。公开接口与类相似，一个文件只能有一个public接口，且与文件名相同。 在一个文件中不可同时定义一个public接口和一个public类。

接口中可以包含多个方法，也可以定义常量。接口中所有方法自动属于public和abstract，所以不能在接口中实现方法。在接口中声明方法时不必提供修饰符public，但在类实现接口时public不可省略，如果省去public则在编译的时候提示出错。而且类要实现接口中所有的方法否则类就是一个抽象类。接口中可以定义常量，常量自动具有public，static，final属性。接口决不能含有实例域，可以将接口看成是没有实例域的抽象类。

接口不是类，不能使用new运算法实例化一个接口，虽然不能构造接口的对象，但可以声明接口的变量，接口变量必须引用实现了接口的类的对象。接口可以像建立继承关系一样，形成一条或多条从较高通用性到较高专用性的接口链。要注意接口继承接口使用关键字extends，并且可以进行多继承。类实现接口使用关键字implements，可以实现多个接口，并同时继承一个且最多一个超类。

接口与抽象类：一个类可以实现多个接口，但是一个类只能有一个超类。类与超类的关系是“is-a”，类与被实现接口的关系是“like-a”。抽象类可以包含据体数据和具体方法，接口只能包含常量和抽象方法。

PS：可以使用instanceof检查一个对象是否属于某个特定的类，也可以使用instanceof检查一个对象是否实现了某个特定的接口。

## NATIVE

JAVA编程语言使用关键字native提醒编译器被修饰的方法将在外部定义，而且方法标题后直接跟分号，这种声明方式和抽象方法类似。

```java
class HelloNative{
    public native void greeting();
}
```

如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法。本地方法非常有用，因为它有效地扩充了jvm。事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。

PS：通过java.system.loadLibrary()方法装载含有本地方法的库。

## PRIVATE，PROTECTED，PUBLIC

这三个修饰符都是用来控制类和成员的访问级别。还有一个访问级别叫做包级私有（package-private），也就是没有修饰符修饰缺省（default）的访问级别。
对于顶层的类（非嵌套的类）和接口，只有两种可能的访问级别：包级私有的（package-private）和公有的（public）。如果使用public修饰符声明了顶层类或者接口，那它就是公有的；否则就是包级私有的。

如果类或者接口能够被做成包级私有的，它就应该被做成包级私有的。通过把类或者接口做成包级私有，它实际上成了这个包的实现的一部分，而不是该包导出API的一部分，在以后的发行版本中，可以对它进行修改，替换或者删除，而无需担心会影响到现有客户端程序。如果把它做成公有的，你就有责任永远支持它，以保持它们的兼容性。

如果一个包级私有的顶层类（或者接口）只是在某个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类。这样可以将它的可访问范围从包中所有类缩小到了使用它的那个类。然而，降低不必要公有类的可访问性，比降低包级私有的顶层类的可访问性重要得多：因为公有类是包的API的一部分，而包级私有的顶层类则已经是这个包的实现的一部分。

对于成员（域，方法，嵌套类和嵌套接口）有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：

+ 私有的（private） —— 只有在声明该成员的顶层类内部才可以访问这个成员。
+ 包级私有（package-private） —— 声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为“缺省（default）访问级别”，如果没有为成员指定访问修饰符，就采用这个访问级别。
+ 受保护的（protected） —— 声明该成员的类的子类可以访问这个成员，并且，声明该成员的包内部的任何类可以访问这个成员。（分为在同一个包内和不在同一个包内）
+ 公有的（public） —— 在任何地方都可以访问该成员

在设计一个类时，只有当同一个包内部的另一个类真正需要访问一个成员的时候，你才应该删除private修饰符，使该成员变成包级私有的。如果经常这么做，则应该重新检查系统设计，看是否有另一种分解方案所得到的类，与其他类之间的耦合度会更小。私有成员和包级私有成员都是一个类的实现中的一部分，一般不会影响它的导出的API。然而如果这个类实现了serializable接口，这些域就有可能会被“泄露”到到导出API中。

对于公有类的的成员，当访问级别从包级私有变成保护级别时，会大大增强可访问性。受保护的成员是类的导出API的一部分，必须永远得到支持。导出的类的受保护成员也代表了该类对于某个实现细节的承诺。受保护的成员应该尽量少用。如果方法覆盖了超类中的一个方法，子类中的访问级别就不允许低于超累中的访问级别。这样可以确保任何可使用超类的实例的地方也都可以吃用子类的实例。

实例域决不能公有，如果域是非final的，或者是一个指向可变对象的final引用，那么一旦使这个域成为公有的，就放弃了对存储在这个域中的值进行限制的能力；这意味着，你也放弃了强制这个域不可变的能力。因此，包含公有可变域的类并不是线程安全的。

同样的建议也适用于静态域，除非通过公有的静态final域来暴露一些常量。这些域要么包含基本类型的值，要么包含指向不可变对象的引用。如果final域包含可变对象的引用，它便具有非final域的所有缺点。虽然本身不能被修改，但是它所引用的的对象却可以被修改——这会导致灾难性的后果。

总而言之，应该始终尽可能降低可访问性。除了公有静态final域的特殊情况外，公有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都是不可变的。

## STATIC

static修饰符可以用来修饰域，方法，初始化块，类。

+ static修饰域和方法。

如果将域用static修饰，则每个类中只有一个这样的域。每个对象对所有的实例域都有一份自己的拷贝，而静态域则是共享的。静态变量用的相对较少，而静态常量用的相对较多。

静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有this参数的方法。因为静态方法不能操作对象，所以不能在静态方法中访问实例域，但是可以访问自身类中的静态域。静态方法可以被类调用，也可以被对象调用。在下面两种情况下使用静态方法：

1. 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供。
2. 一个方法只需要访问类的静态域。

静态方法可以用来做静态工厂方法，代替构造器。和静态域配合可以实现单例模式。main函数也是一个静态方法。

+  static修饰初始化块

static修饰初始化块主要是有一个顺序问题。静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序以此是（静态变量、静态初始化块）>（变量、初始化块）>构造器。括号内的各项是由在代码中的顺序决定的。静态初始化块与静态方法一样，不能向对象实施操作，也就不能访问实例域和非静态方法。

在继承关系中，父类的静态变量和静态初始化块先执行，然后是子类的静态变量和静态初始化块执行，然后才是父类的变量，初始化块和构造器，最后是子类的变量，初始化块和构造器。

+ static修饰类

如果一个类要被声明为static的，只有一种情况，就是静态成员类。静态成员类是最简单的一种嵌套类。最好把它看做是普通类，只是刚好声明在了另一个类的内部，它可以访问外部类的所有成员，包括那些声明为私有的成员。静态成员类是外部类的一个静态成员，与其他静态成员一样，也遵从同样的可访问性规则。

静态成员类的一种常见用法是作为公有的辅助类，仅当与它的外部类一起使用时才有意义。比如使用builder模式构建类的对象（effective java 2-2）。而私有静态成员类的一种常见用法是用来代表外部类所代表的对象的组件。

如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类。如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。保存这份引用要消耗时间和空间，并会导致外围实例在符合垃圾回收时却仍然得以保留。如果在没有外围实例的情况下，也需要分配实例，就必须使用静态成员类，因为非静态成员类的实例必须要有一个外围实例。

静态成员类的一种常见用法是作为公有的辅助类，仅当与它的外部类一起使用时才有意义。比如使用builder模式构建类的对象（effective java 2-2）。而私有静态成员类的一种常见用法是用来代表外部类所代表的对象的组件。

如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类。如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。保存这份引用要消耗时间和空间，并会导致外围实例在符合垃圾回收时却仍然得以保留。如果在没有外围实例的情况下，也需要分配实例，就必须使用静态成员类，因为非静态成员类的实例必须要有一个外围实例。

## STRICTFP

strictfp, 即 strict float point (精确浮点)。

strictfp 关键字可应用于类、接口或方法。使用 strictfp 关键字声明一个方法时，该方法中所有的float和double表达式都严格遵守FP-strict的限制,符合IEEE-754规范。当对一个类或接口使用 strictfp 关键字时，该类中的所有代码，包括嵌套类型中的初始设定值和代码，都将严格地进行计算。严格约束意味着所有表达式的结果都必须是 IEEE 754 算法对操作数预期的结果，以单精度和双精度格式表示。如果你想让你的浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字strictfp.

## SYNCHRONIZED

如果一个方法使用synchronized修饰符，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。代码示例：

```java
public synchronized void method() {
    // TODO
}
```

等价于

```java
public void method() {
    this.intrinsicLock.lock();
    try {
        // TODO
    } finally {
        this.intrinsicLock.unlock();
    }
}
```

synchronized修饰符还可以修饰一个代码块，当线程进入如下形式的阻塞：

```java
synchronized(obj) {
    // TODO
}
```

于是它获得了obj的锁。

可以看到使用synchronized修饰符编写代码要整洁的多。你必须了解每个对象都有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized方法的线程，由条件来管理那些调用wait的线程。

将静态方法声明为synchronized也适合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。例如A类有一个静态同步的方法，那么当该方法被调用时，A.class对象被锁住。因此没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。

最好不要使用synchronized修饰符。许多情况下你可以使用java.util.concurrent包中的一种机制，它会为你处理所有的加锁。过度的同步可能会导致性能降低，死锁，甚至不确定的行为。

## TRANSIENT

transient可以修饰域。java提供了一个框架，用来将对象编码成字节流（序列化 serializing），并从字节流编码中重新构建对象（反序列化 deserializing）。transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉。 意思就是临时的，不会随对象一起序列化，所以在反序列化时这个修饰符修饰的域将被初始化为它们的默认值：对于对象引用，默认值为null；对于数值基本域，默认值为0；对于boolean域，默认值为false。如果 这些值不能被任何transient域所接受，你就必须提供一个readObject方法，它首先调用defaultReadObject，然后把这些transient域恢复为可接受的值。另一种方法是，这些域可以被延迟到第一次使用的时候才 真正的被初始化。

## VOLATILE

volatile可以修饰域，保证任何一个线程在读取该域的时候都将看到最近刚刚写入的值，但是volatile修饰符不执行互斥访问。volatile修饰的域在每次被线程访问时，都强迫从共享内存中重新读取该域的值。而且当域值发生改变时，强迫线程将变化值写回到共享内存中。这样在任何一个时刻，两个不同的线程总是看到被修饰域的同一个值。

java语言规范中写到：为了获取最佳的速度，允许线程保存共享成员变量的私有拷贝，而且只有当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。

这样当多个线程与同一个对象进行交互时，就必须要让线程及时得到共享成员变量的变化。而volatile修饰符的作用就是提示VM：对于被修饰成员变量不允许线程保存私有拷贝，而应让线程直接与共享成员变量交互。在使用volatile修饰符是要小心下面情况：

```java
//Broken - requires synchronization!
private static volatile int nextSerialNumber = 0 ;

public static int generateSerialNumber() {
    return nextSerialNumber ++;
}
```


这个方法的目的是要确保每个调用都返回不同的值（只要不超过2的32次方个调用）。这个方法的状态只包含一个原子访问的域：nextSerialNumber，这个域的多有可能的值都是合法的。因此不需要任何同步来保护它的约束条件。然而，如果没有同步，这个方法仍然无法正常工作。

 问题在于，增量操作符（++）不是一个原子操作。它在nextSerialNumber域中执行两项操作：首先读取它的值，然后写回一个新值，相当于原来的值再加上1。如果第二个线程在第一个线程读取旧值和写回一个新值期间读取这个域，第二个线程就会与第一个线程一起看到同一个值，并返回相同的序列号。这就是安全性失败（safety failure）：这个程序会计算出错误的结果。

修正generateSerialNumber方法的一种方法是在它的声明中增加synchronized修饰符。这样可以确保多个调用不会交叉存取，确保每个调用都会看到之前多有调用的效果。一旦这么做，就可以且应该从nextSerialNumber中删除volatile修饰符。为了让这个方法更可靠，要用long代替int，或者在nextSerialNumber快要重叠时抛出异常。

最好的方法是使用类AtomicLong，它是java.util.concurrent.atomic的一部分。它所做的工作正是这里需要的。并且有可能比同步版的generateSerialNumber执行的更好：

```java
private static final AtomicLong nextSerialNumber = new AtomicLong();

public static long generateSerialNumber() {
    return nextSerialNumber.getAndIncrement();
}
```

当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。未能同步共享可变数据会造成程序的活性失败（liveness failure）和安全失败（safety failure）。这样的失败是最难调试的。它们可能是间歇性的。而且与时间相关，程序的行为在不同的VM上可能根本不同。如果只需要线程之间的交互通信，而不需要互斥，volatile修饰符就是一种可以接受的同步形式，但是要正确使用它可能需要一些技巧。

当要访问的变量已经在synchronized代码块中，或者为常量时，不必使用该修饰符。

## 参考
+ 《Core JAVA》
+ 《effective JAVA》
